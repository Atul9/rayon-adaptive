- cap: default policy + check tasks of sizes 0 are not stolen but discarded immediately
- fromrange : to_sequential is not that ok

- if we use into_iter and then parallel reduction on each block then ByBlocks is asked twice for sizes
   is it a big deal ?

- what power do we have when we chain and how do we do it ?
     ----> we can implement chain 3 times for each power level

- add unsafe to directly replace iterators when extracting ?
  -> it's not that easy. division is ok but we also need to move without dividing.
  (for example in blocks iterator when no sizes are left or in help when storing back in list)
  if iterators are bounded that's ok we could just divide at length but what if they are infinite ?

- can a Fn not implement Clone ? if so should we switch to Arc for sharing fn ?

- we can do Take like that:
   if indexed we change size
   if not indexed we cannot change size
   -> we need to parametrize take by the power or have several ones

- double check the divide_at(0) in help_work is not needed in help.rs even with special iterators like folders

- use the same trick as rayon to get our own Try and implement try_fold for our sequential iterators

- Cap has three different problems:
   - first do we need to distinguish between dividing on the left for blocks iterators and dividing on the right for //ism ?
                -> well, we could just mem::swap
   - we need a way to fail dividing. -> we could maybe divide to obtain a size of 0 on the right and then test for sizes in the stealer
                -> dividing at length seems fine ; we cannot divide for parallelism on an infinite iterator
   - we need to change atomic counter when dropping but if we implement drop we cannot move anymore
                -> could we decrease at last iteration ? -> yes we can

   ----> isn't it better to just go away from the move api ?
       go from divide(self) -> (Self, Self) to divide(&mut self) -> Self

       we will then have the same problems as slice's IterMut with lifetimes (currently extract_iter forced us to switch to options
       in order to divide without borrowing).

   so the debate is between move api and no pb with lifetimes but pb with drop and the borrow api with the reversed problems.
   ***********
   ANYWAY we cannot and should not drop on parallel iterators because the real drop should be done on the final sequential iterator.
   so: let's stick to moving divides. we can get some convenience functions for borrow_divide.
   the only drawback is that we make no distinctions between splitting for blocks and splitting for parallelism
   --> could we actually do both ? since we could specialize the borrow_divide_at method ?
   ***********


*** api changes to discuss:
  - cap pb: is not moving really a pb ?
  - do all Fn implement Clone ? is Sync better than Send (if we go to Arc)
  - unsafety of successors

